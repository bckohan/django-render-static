"""
Template tags and filters available when the render_static app is installed.
"""

from enum import Enum
from types import ModuleType
from typing import Any, Collection, Iterable, List, Optional, Type, Union

from django import template
from django.conf import settings
from django.utils.module_loading import import_string
from django.utils.safestring import SafeString
from render_static.transpilers import (
    Transpiler,
    TranspilerTarget,
    TranspilerTargets,
)
from render_static.transpilers.defines_to_js import DefaultDefineTranspiler
from render_static.transpilers.enums_to_js import EnumClassWriter
from render_static.transpilers.urls_to_js import ClassURLWriter

register = template.Library()

__all__ = [
    'split',
    'defines_to_js',
    'urls_to_js',
    'enums_to_js'
]


@register.filter(name='split')
def split(to_split: str, sep: Optional[str] = None) -> List[str]:
    """
    Django template for python's standard split function. Splits a string into
    a list of strings around a separator.

    :param to_split: The string to split
    :param sep: The separator characters to use as split markers.
    :return: A list of strings
    """
    if sep:
        return to_split.split(sep)
    return to_split.split()


@register.simple_tag
def transpile(
    targets: Union[TranspilerTargets, TranspilerTarget],
    transpiler: Union[Type[Transpiler], str],
    **kwargs
) -> str:
    """
    Run the given transpiler on the given targets and write the generated
    javascript in-place.

    :param targets: A list or single transpiler target which can be an import
        string a module type or a class.
    :param transpiler: The transpiler class or import string for the transpiler
        class to use.
    :param kwargs: Any kwargs that the transpiler takes.
    :return:
    """
    if isinstance(transpiler, str):
        # mypy doesn't pick up this switch from str to class, import_string
        # probably untyped
        transpiler = import_string(transpiler)

    if isinstance(targets, (type, str)) or not isinstance(targets, Collection):
        targets = [targets]

    return SafeString(
        transpiler(  # type: ignore
            **kwargs
        ).transpile(targets)
    )


@register.simple_tag
def urls_to_js(  # pylint: disable=R0913,R0915
        transpiler: Union[Type[Transpiler], str] = ClassURLWriter,
        url_conf: Optional[Union[ModuleType, str]] = None,
        indent: str = '\t',
        depth: int = 0,
        include: Optional[Iterable[str]] = None,
        exclude: Optional[Iterable[str]] = ('admin',),
        **kwargs
) -> str:
    """
    Dump reversible URLs to javascript. The javascript generated provides
    functions for each fully qualified URL name that perform the same service
    as Django's URL `reverse` function. The javascript output by this tag
    isn't standalone. It is up to the caller to embed it in another object.
    For instance, given the following urls.py:

    .. code-block::

        from django.urls import include, path
        from views import MyView

        urlpatterns = [
            path('my/url/', MyView.as_view(), name='my_url'),
            path('url/with/arg/<int:arg1>', MyView.as_view(), name='my_url'),
            path('sub/', include('other_app.urls', namespace='sub')),
        ]

    And the other app's urls.py:

    .. code-block::

        from django.urls import path
        from views import MyView

        urlpatterns = [
            path('detail/<uuid:id>', MyView.as_view(), name='detail'),
        ]

    And the following template:

    .. code-block::

        {% urls_to_js %}

    You can now reverse code in the javascript like this:

    .. code-block::

        const urls = URLResolver():

        # /my/url/
        console.log(urls.reverse('my_url));

        # /url/with/arg/143
        console.log(urls.reverse('my_url', {kwargs: {'arg1': 143}}));

        # /sub/detail/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa
        console.log(
            urls.reverse(
                'other:detail',
                {kwargs: {'id': 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'}}
            )
        );


    .. note::
        Care has been taken to harden this process to changes to the Django url
        resolution source and to ensure that it just works with minimal
        intervention.

        The general strategy of this process is two staged. First a tree
        structure is generated by walking the urlpatterns structure that
        contains the url patterns and resolves all their fully qualified names
        including all parent namespaces. URLs and namespaces are included and
        excluded at this stage based on the include/exclude parameters. The
        branches of the tree are namespaces and the leaves are fully qualified
        URL names containing lists of corresponding URLPatterns.

        The second stage recursively walks the tree, writing javascript as it
        enters namespaces and encounters URLPatterns. Multiple URLs may be
        registered against the same fully qualified name, but may be
        distinguished by the named parameters they accept. One javascript
        function is generated for each fully qualified URL name, that will
        select the correct URL reversal based on the names of the parameters
        passed in and map those parameter values to the correct
        placeholders in the URL. To ensure the outputs of the javascript match
        Django's `reverse` the strategy is to use the results of the `reverse`
        call for the fully qualified name. Placeholder values are passed into
        `reverse` and then overwritten with javascript substitution code based
        on the regex grouping information. This strategy avoids as much error
        prone regex/string processing as possible. The concession here is that
        placeholder values must be supplied by the user wherever we cant infer
        them. When using path instead of re_path we can use default
        placeholders for all the known converters. When using re_path or custom
        path converters users must register placeholders by parameter name,
        converter type, or app_name. Libraries exist for generating string
        patterns that match regex's but none seem reliable or stable enough to
        include as a dependency.

    :param transpiler: The transpiler class that will generate the JavaScript,
        as either a class or an import string. May be one of the built-ins or a
        user defined transpiler.
    :param url_conf: The root url module to dump urls from,
        default: settings.ROOT_URLCONF
    :param indent: string to use for indentation in javascript, default: '  '
    :param depth: the starting indentation depth, default: 0
    :param include: A list of path names to include, namespaces without path
        names will be treated as every path under the namespace.
        Default: include everything
    :param exclude: A list of path names to exclude, namespaces without path
        names will be treated as every path under the namespace.
        Default: exclude nothing
    :param kwargs: Extra kwargs that will be passed to the visitor class on
        construction. All visitors are passed indent, and depth.
    :return: A javascript object containing functions that generate urls with
        and without parameters
    """

    kwargs['depth'] = depth
    kwargs['indent'] = indent
    kwargs['include'] = include
    kwargs['exclude'] = exclude

    return transpile(
        targets=(url_conf if url_conf else settings.ROOT_URLCONF),
        transpiler=transpiler,
        **kwargs
    )


@register.simple_tag
def defines_to_js(
        defines: Union[
            ModuleType,
            Type[Any],
            str,
            Collection[Union[ModuleType, Type[Any], str]]
        ],
        transpiler: Union[Type[Transpiler], str] = DefaultDefineTranspiler,
        indent: str = '\t',
        depth: int = 0,
        **kwargs
) -> str:
    """
    Transpile defines from the given modules or classes into javascript.

    :param defines: A module, class or import string to either.
    :param transpiler: The transpiler class or import string for the transpiler
        class that will perform the conversion,
        default: DefaultDefineTranspiler
    :param indent: The indent string to use
    :param depth: The depth of the initial indent
    :param kwargs: Any other kwargs to pass to the transpiler.
    :return: SafeString of rendered transpiled code.
    """
    return transpile(
        targets=defines,
        transpiler=transpiler,
        indent=indent,
        depth=depth,
        **kwargs
    )


@register.simple_tag
def enums_to_js(
        enums: Union[
            ModuleType,
            Type[Enum],
            str,
            Collection[Union[ModuleType, Type[Enum], str]]
        ],
        transpiler: Union[Type[Transpiler], str] = EnumClassWriter,
        indent: str = '\t',
        depth: int = 0,
        **kwargs
) -> str:
    """
    Transpile the given enumeration(s).

    :param enums: An enum class or import string or a collection of either to
        transpile.
    :param transpiler: A transpiler class or import string of the transpiler
        class to use for the transpilation.
    :param indent: The indent string to use
    :param depth: The depth of the initial indent
    :param kwargs: Any other parameters to pass to the configured transpiler.
        See transpiler docs for details.
    :return: SafeString of rendered transpiled code.
    """
    return transpile(
        targets=enums,
        transpiler=transpiler,
        indent=indent,
        depth=depth,
        **kwargs
    )
